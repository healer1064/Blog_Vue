---
title: '创建型设计模式'
date: 2020-08-23
categories:
- "Csharp"
tags:
- 学习笔记
sidebar: auto
isFull: true
isShowComments: true
isShowIndex: true
---

> 设计模式三大类<br>
  1、创建型设计模式：关注对象的创建<br>
  2、结构型设计模式：关注类与类之间的关系<br>
  3、行为型设计模式：关注对象和行为的分离

-------------------

## 单例模式

单例模式就是限制了对象的创建，重用了对象

```csharp
//单例模式的三种方式      
/// 一
//  ***********************************************************************************
/// <summary>
/// 懒汉式
/// </summary>
public class Singleton
{
    /// <summary>
    /// 构造函数私有化，避免别人还去new
    /// 公开的静态方法提供对象实例
    /// 初始化一个静态字段用于返回，保证全局都是这一个
    /// </summary>
    private Singleton()
    {
        Console.WriteLine($"{this.GetType().Name}被构造一次");
    }      
    private static volatile Singleton _singleton = null;  //volatile 促进线程安全  让线程按顺序操作
    private static readonly object Singleton_Lock = new object();      
    public static Singleton CreateSingleton()
    {
        if (_singleton == null)  //是——singleton已经被初始之后，就不要进入锁等待了
        {
            lock (Singleton_Lock)  //保证任意时刻只有一个线程进入lock线程,也限制了并发
            {
                if (_singleton == null)   //保证只实例化一次
                {
                    _singleton = new Singleton();
                }
            }
        }
        return _singleton;
    }      
    public int iTotal = 0;
    public void Show()
    {
        lock (Singleton_Lock)   //保证多线程调用时得到正确的结果
        {
            this.iTotal++;
        }
    } 
}

/// 二
//  ***********************************************************************************
/// <summary>
/// 饿汉式
/// </summary>
public class SingletonSecond
{
    /// <summary>
    /// 1、构造函数耗时耗资源
    /// </summary>
    private SingletonSecond()
    {
        Console.WriteLine($"{this.GetType().Name}被构造一次");
    }
    /// <summary>
    /// 静态构造函数：由CLR保证，程序第一次使用这个类型前被调用，且只调用一次
    ///
    /// 做一些检测、初始化的动作
    /// 写日志功能的文件夹检测
    /// XML配置文件
    /// </summary>
    static SingletonSecond()
    {
        _singletonSecond=new SingletonSecond();
        Console.WriteLine($"SingletonSecond 被启动");
    }
    private static SingletonSecond _singletonSecond = null;
    public static SingletonSecond CreateInstance()
    {
        return _singletonSecond;
    }
    public static void Test()
    {
        Console.WriteLine("Test2");
    }
    public int iTotal = 0;
    public void Show()
    {
        this.iTotal++;
    }
}

/// 三
//  ***********************************************************************************
public class SingletonThird
{
    private SingletonThird()
    {
        Console.WriteLine($"{this.GetType().Name} 被构造一次");
    }
    /// <summary>
    /// 静态字段：在第一次使用这个类之前，由CLR保证，初始化且只初始化一次
    /// 这个比静态构造函数还早
    /// </summary>
    private static SingletonThird _singletonThird=new SingletonThird();
    public static SingletonThird CreateInstance()
    {
        return _singletonThird;
    }
    public void Show()
    {
        Console.WriteLine($"这里是{this.GetType().Name}.Show ");
    }
}
```

## 原型模式

原型模式就是换个方法创建对象，不走构造函数，而是内存拷贝，得到不同的对象

```csharp
/// <summary>
/// 原型模式:在单例的基础上升级了一下，把对象从内存层面克隆了一下，然后返回
/// 既是一个新对象，但是又不是new出来的
/// </summary>
public class Prototype
{
    private Prototype()
    {
        long lResult = 0;
        for (int i = 0; i < 10000; i++)
        {
            lResult += 1;
        }
        Thread.Sleep(1000);
        Console.WriteLine($"{this.GetType().Name} 被构造一次");
    }
    private static Prototype _prototype = new Prototype();
    public static Prototype CreateInstance()
    {
        Prototype prototype = (Prototype) _prototype.MemberwiseClone();
        return prototype;
    }
}
```

## 简单工厂、工厂方法、抽象工厂

 - 简单工厂

 - 工厂方法：完美的遵循了开闭原则

 - 抽象方法：屏蔽了对象的创建，约束了产品簇的完整创建




